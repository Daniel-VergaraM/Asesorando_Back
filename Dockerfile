# --- Stage 1: Build the application ---
# Use a Maven image with the required JDK version (your POM uses Java 21)
# Multi-stage build to keep the final image small.
FROM maven:3.9.6-eclipse-temurin-21 AS build

# Set the working directory inside the build container
WORKDIR /app

# Copy the pom.xml to download dependencies first (Maven cache)
COPY pom.xml ./

# Download dependencies (optional but speeds up subsequent builds if pom.xml doesn't change)
RUN mvn dependency:go-offline -B

# Copy the rest of the source code
COPY src ./src

# Package the application using Maven.
# -B for batch mode (non-interactive)
# -DskipTests to speed up the build for deployment (assumes tests are run in CI/local)
# This will execute the 'package' goal defined in your pom.xml, creating the JAR in /app/target/
RUN mvn -B package -DskipTests

# --- Stage 2: Create the final runtime image ---
# Use a lightweight JRE base image for running Java
FROM eclipse-temurin:21-jre-jammy

# Set the working directory in the final image
WORKDIR /app

# Copy ONLY the built JAR from the previous build stage
# Ensure the JAR name matches the one generated by your pom.xml
# Using a wildcard to handle versioned JAR names.
COPY --from=build /app/target/Asesorando_Back-0.0.1-SNAPSHOT.jar app.jar

# Expose the port your Spring Boot application listens on (default is 8080)
EXPOSE 8080

# Define the PORT environment variable (Render will inject this, but we set a default of 8080)
ENV PORT 8080

# Command to run the application when the container starts
# Use the PORT environment variable provided by Render to configure the server port.
ENTRYPOINT ["java", "-jar", "-Dserver.port=${PORT}", "app.jar"]
